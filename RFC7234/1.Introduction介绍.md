## 1. 介绍

http通常用于分布式信息系统，通过使用响应的缓存可以提高性能。本文档定义了相关方面的HTTP/1.1中关于缓存和重用响应消息的部分。

http缓存是一个本地存储，其子系统控制了存储检索和删除消息缓存。缓存存储了可缓存的响应和请求，以减少未来的响应时间和网络带宽消耗。任何客户端或服务端**可以**使用缓存，虽然作为一个隧道的服务端不能使用缓存。

共享缓存是存储多个用户响应的缓存；共享缓存一般来说（但不全是）是作为中介的一部分部署的。相对的，一个私有缓存是针对单个用户的；通常情况下，私有缓存是作为用户代理的组件实现的。

通过复用之前已有的的响应消息来响应当前请求，HTTP/1.1中的缓存的目标是希望显著提升性能。 已存储的响应被认为是“新”(fresh)的,“新”(fresh)的定义在4.2章节，如果响应可以重用而不需要进行“验证”(validation)（检查源服务端，看看该响应对应该请求是否仍然有效）。每次重用一个新（fresh）的响应可以减少延迟和网络开销。当一个缓存的响应并不新（fresh）,它可能仍然是可重用的如果它可以通过验证过程刷新(4.3节)或者源不可用时(4.2.4节)。

#### 1.1. 一致性和错误处理

本文档中使用了一些关键字**必须**, **禁止**, **要求**, **允许**, **不允许**, **应该**, **不应该**, **推荐**, **可以**, **可选**. 这些关键字的解释参见[RFC 2119].

一致性和错误处理的要求参见2.5节.

#### 1.2. 语法符号

本文档使用增加了列表扩展(第7章)的扩展巴科斯范式(Augmented Backus-Naur Form, ABNF)(RFC 5234)描述协议语法. 相比于「*」操作符, 增加的列表扩展使用「#」操作符更简洁地表达逗号分隔的列表. 附录B将对此进行描述.附录C显示了收集到的语法与所有标准ABNF符号的扩展列表。

###### 1.2.1. 整数秒

整数秒规则指定一个非负整数，代表时间中的秒数。

> delta-seconds  = 1*DIGIT

接收端解析该delta-seconds值，将其转换成二进制形式，使用31位二进制位数来表示该非负整数。 如果缓存收到一个delta-seconds大于31位能表示的最大值时，或者基于它的任何后续计算溢出的话， 缓存**必须**将该值当作 2147483648 (2^31) 或者本身能展示的最大正整数.

> 备注：2147483648这个值是历史遗留问题，用来表示无限大（超过68年），而且不一定存储成二进制形式。某些扩展在溢出的情况下可以将这个值当作字符串，但是计算过程中仍可以将该值当成数值进行计算。重要的点是溢出在这个过程中可以被检测出来并且在之后的计算过程中不会被当成负数。

## 2. 缓存操作的概述

适合的缓存操作通过减少传输已存在于缓存的信息来展示HTTP传输的语义。尽管对于HTTP来说缓存是**可选**的特性，却可以认为复用缓存的响应是值得的，在没有其他要求和本地配置的前提下，复用缓存是默认的行为。 因此，HTTP协议中的缓存主要用于防止缓存端缓存不需要缓存的响应或者是复用一个不合适的存储响应，而不是强制存储和复用某些特定响应。

每一个缓存条目由一个缓存键和针对使用该键的请求的一个或多个HTTP响应。比较常见的缓存条目是一个成功请求的结果:例如：一个200（OK）的GET请求的响应，这个结果包括了这个请求资源的展示（第4.3.1章节[RFC7231]）。可是以下场景也是可以被缓存：一个永久重定向，负面的结果（例如，404（Not Found）），未完成的结果（例如，206（Patial Content）），所有允许缓存并且定义了合适的缓存键的非GET请求响应。

缓存主键包括了请求方法和目标地址。然而，因为HTTP缓存在大部分的使用场景是限制在缓存GET响应，很多缓存端就简单的拒绝其他请求方法，仅仅使用地址作为缓存键。

如果请求地址受制于内容协商（content negotiation），缓存条目可以包括多个存储响应，并将原始请求头的选择头字段（4.1章）值作为第二键用于区分。

## 3. 在缓存中存储响应

缓存端**禁止**存储任意请求的响应，除非：

* 缓存端可以理解请求方法，并且是被定义成可缓存的。

* 缓存段可以理解响应状态码。

*  “no-store”缓存指令（5.2章）没有在请求或者响应头字段中出现

* 在缓存是共享的情况下，“private”响应指令（5.2.2.6章）没有在响应头中出现

* 在缓存是共享的情况下，认证的头字段（4.2章[RFC7235]）没有在请求中出现，除非响应特别说明允许缓存（3.2章）

* 响应满足以下任意条件：

    *  包含了一个Expires头字段（5.3章）
    
    *  直接包含一个max-age响应（5.2.2.8章）
    
    *  在缓存是共享的前提下，直接包含一个s-maxage响应（5.2.2.9章）
    
    *  直接包含缓存控制的扩展，允许该响应可以被缓存
    
    *  响应状态码默认定义成可缓存的（4.2.2章）
    
    *  直接包含一个公开响应（5.2.2.5章）
    
注意到，以上列出的任意要求可以被一个缓存扩展重写覆盖（5.2.3章节）。

在这种情况下,如果能识别并实现了所有指定的缓存相关的行为，缓存就“理解”了请求方法或响应状态代码。

注意到，正常操作下，某些缓存不会缓存那些既没有缓存验证也没有指定过期时间的响应，因为这些响应一般都是没什么缓存价值的。然而，缓存这些响应也是可以的。

#### 3.1.  存储不完整响应

一般都会认为响应信息是完整的，只要连接被关闭前所有的字节码都收到了。如果请求方法是GET，响应状态码是200（Ok），整个响应头都已经收到的前提下，缓存端**可以**缓存不完整的响应消息并在缓存条目中标识该条目为不完整的。以此类推，一个206（Partial Content）响应消息**可以**被存储成不完整的200（OK）缓存条目。 然而，缓存端**禁止**存储不完整或者partial-content的响应，如果该响应不支持Range和Content-Range头字段或者缓存端无法理解字段值。

缓存端**可以**通过一个部分内容请求（[RFC7233]）并合并成功响应到原有的不完整响应中来完整原有响应，以上在3.3章定义。缓存端**禁止**使用不完整的响应来回应请求，除非该响应是完整或者请求的是缓存范围内的部分内容。缓存端**禁止**在没有明确标识（例如 使用206（Partial Content）响应状态码）的情况下向客户端发送一个部分响应。

#### 3.2  存储需要认证的请求

公共缓存端**禁止**向带有认证头字段（4.2章[RFC7235]）需要认证的请求回复缓存的相应信息, 除非缓存端允许这样的操作。

本规范下，以下缓存控制指令（5.2.2章）有这样的作用：must-revalidate，public和s-maxage。

注意到，公共缓存端不允许回复旧缓存给带有"must-revalidate"和/或"s-maxage"头字段的请求。
    







































