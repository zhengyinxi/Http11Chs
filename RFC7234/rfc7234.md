## 1. 介绍

http通常用于分布式信息系统，通过使用响应的缓存可以提高性能。本文档定义了相关方面的HTTP/1.1中关于缓存和重用响应消息的部分。

http缓存是一个本地存储，其子系统控制了存储检索和删除消息缓存。缓存存储了可缓存的响应和请求，以减少未来的响应时间和网络带宽消耗。任何客户端或服务端**可以**使用缓存，虽然作为一个隧道的服务端不能使用缓存。

共享缓存是存储多个用户响应的缓存；共享缓存一般来说（但不全是）是作为中介的一部分部署的。相对的，一个私有缓存是针对单个用户的；通常情况下，私有缓存是作为用户代理的组件实现的。

通过复用之前已有的的响应消息来响应当前请求，HTTP/1.1中的缓存的目标是希望显著提升性能。 已存储的响应被认为是“新”(fresh)的,“新”(fresh)的定义在4.2章节，如果响应可以重用而不需要进行“验证”(validation)（检查源服务端，看看该响应对应该请求是否仍然有效）。每次重用一个新（fresh）的响应可以减少延迟和网络开销。当一个缓存的响应并不新（fresh）,它可能仍然是可重用的如果它可以通过验证过程刷新(4.3节)或者源不可用时(4.2.4节)。

#### 1.1. 一致性和错误处理

本文档中使用了一些关键字**必须**, **禁止**, **要求**, **允许**, **不允许**, **应该**, **不应该**, **推荐**, **可以**, **可选**. 这些关键字的解释参见[RFC 2119].

一致性和错误处理的要求参见2.5节.

#### 1.2. 语法符号

本文档使用增加了列表扩展(第7章)的扩展巴科斯范式(Augmented Backus-Naur Form, ABNF)(RFC 5234)描述协议语法. 相比于「*」操作符, 增加的列表扩展使用「#」操作符更简洁地表达逗号分隔的列表. 附录B将对此进行描述.附录C显示了收集到的语法与所有标准ABNF符号的扩展列表。

###### 1.2.1. 整数秒

整数秒规则指定一个非负整数，代表时间中的秒数。

> delta-seconds  = 1*DIGIT

接收端解析该delta-seconds值，将其转换成二进制形式，使用31位二进制位数来表示该非负整数。 如果缓存收到一个delta-seconds大于31位能表示的最大值时，或者基于它的任何后续计算溢出的话， 缓存**必须**将该值当作 2147483648 (2^31) 或者本身能展示的最大正整数.

> 备注：2147483648这个值是历史遗留问题，用来表示无限大（超过68年），而且不一定存储成二进制形式。某些扩展在溢出的情况下可以将这个值当作字符串，但是计算过程中仍可以将该值当成数值进行计算。重要的点是溢出在这个过程中可以被检测出来并且在之后的计算过程中不会被当成负数。

## 2. 缓存操作的概述

适合的缓存操作通过减少传输已存在于缓存的信息来展示HTTP传输的语义。尽管对于HTTP来说缓存是**可选**的特性，却可以认为复用缓存的响应是值得的，在没有其他要求和本地配置的前提下，复用缓存是默认的行为。 因此，HTTP协议中的缓存主要用于防止缓存端缓存不需要缓存的响应或者是复用一个不合适的存储响应，而不是强制存储和复用某些特定响应。

每一个缓存条目由一个缓存键和针对使用该键的请求的一个或多个HTTP响应。比较常见的缓存条目是一个成功请求的结果:例如：一个200（OK）的GET请求的响应，这个结果包括了这个请求资源的展示（第4.3.1章节[RFC7231]）。可是以下场景也是可以被缓存：一个永久重定向，负面的结果（例如，404（Not Found）），未完成的结果（例如，206（Patial Content）），所有允许缓存并且定义了合适的缓存键的非GET请求响应。

缓存主键包括了请求方法和目标地址。然而，因为HTTP缓存在大部分的使用场景是限制在缓存GET响应，很多缓存端就简单的拒绝其他请求方法，仅仅使用地址作为缓存键。

如果请求地址受制于内容协商（content negotiation），缓存条目可以包括多个存储响应，并将原始请求头的选择头字段（4.1章）值作为第二键用于区分。

## 3. 在缓存中存储响应

缓存端**禁止**存储任意请求的响应，除非：

* 缓存端可以理解请求方法，并且是被定义成可缓存的。

* 缓存段可以理解响应状态码。

*  “no-store”缓存指令（5.2章）没有在请求或者响应头字段中出现

* 在缓存是共享的情况下，“private”响应指令（5.2.2.6章）没有在响应头中出现

* 在缓存是共享的情况下，认证的头字段（4.2章[RFC7235]）没有在请求中出现，除非响应特别说明允许缓存（3.2章）

* 响应满足以下任意条件：

    *  包含了一个Expires头字段（5.3章）
    
    *  直接包含一个max-age响应（5.2.2.8章）
    
    *  在缓存是共享的前提下，直接包含一个s-maxage响应（5.2.2.9章）
    
    *  直接包含缓存控制的扩展，允许该响应可以被缓存
    
    *  响应状态码默认定义成可缓存的（4.2.2章）
    
    *  直接包含一个公开响应（5.2.2.5章）
    
注意到，以上列出的任意要求可以被一个缓存扩展重写覆盖（5.2.3章节）。

在这种情况下,如果能识别并实现了所有指定的缓存相关的行为，缓存就“理解”了请求方法或响应状态代码。

注意到，正常操作下，某些缓存不会缓存那些既没有缓存验证也没有指定过期时间的响应，因为这些响应一般都是没什么缓存价值的。然而，缓存这些响应也是可以的。

#### 3.1.  存储不完整响应

一般都会认为响应信息是完整的，只要连接被关闭前所有的字节码都收到了。如果请求方法是GET，响应状态码是200（Ok），整个响应头都已经收到的前提下，缓存端**可以**缓存不完整的响应消息并在缓存条目中标识该条目为不完整的。以此类推，一个206（Partial Content）响应消息**可以**被存储成不完整的200（OK）缓存条目。 然而，缓存端**禁止**存储不完整或者partial-content的响应，如果该响应不支持Range和Content-Range头字段或者缓存端无法理解字段值。

缓存端**可以**通过一个部分内容请求（[RFC7233]）并合并成功响应到原有的不完整响应中来完整原有响应，以上在3.3章定义。缓存端**禁止**使用不完整的响应来回应请求，除非该响应是完整或者请求的是缓存范围内的部分内容。缓存端**禁止**在没有明确标识（例如 使用206（Partial Content）响应状态码）的情况下向客户端发送一个部分响应。

#### 3.2  存储需要认证的请求

公共缓存端**禁止**向带有认证头字段（4.2章[RFC7235]）需要认证的请求回复缓存的相应信息, 除非缓存端允许这样的操作。

本规范下，以下缓存控制指令（5.2.2章）有这样的作用：must-revalidate，public和s-maxage。

注意到，公共缓存端不允许回复旧缓存给带有"must-revalidate"和/或"s-maxage"头字段的请求。尤其是带有"max-age=0, must-revalidate" 或者 "s-maxage=0"的响应不能在没有跟源服务器验证的前提下回复随后的请求。

#### 3.3. 合并部分内容

如果连接过早关闭或者请求本身带了内容范围的要求（[RFC7233]）,响应可能只传输了一部分内容。在若干次这样的传输之后，缓存端可能收到了该响应的若干部分。缓存端**可以**合并这些部分到一个独立的响应里，然后在之后的请求中复用这个响应，不过是在这个请求都使用了同样的验证且缓存端能满足客户端的需求（4.3章[RFC7233]）。

在合并新旧响应的时候，缓存端**必须**满足以下所有条件：

* 删除Warning头字段值中warn-code为1xx的字段（5.5章）；

* 保留Warning头字段值中warn-code为2xx的字段；

* 使用新响应头中所有字段值，除了Content-Range，替换已存储的响应头字段。

## 4. 从缓存中构建响应

当面对请求的时候，缓存端**禁止**复用已存储的响应，除非满足以下所有条件：

* 提供的请求地址URI（5.5章[RFC7230]）和已存储的响应URI相同

* 已存储的响应的请求方法允许该响应被用于回复该请求

* 已存储的响应的头字段与请求相符合

* 提供的请求没有no-cache的标识（5.4章），或者没有no-cache的需求（5.2.1章），除非已存储的响应已经成功验证（4.3章）

* 存储的响应没有no-cache的标识和需要（5.2.2.2章），除非已存储的响应已经成功验证（4.3章）

* 已存储的响应满足以下任意要求：

    * 新(fresh)的（4.2章）
    
    * 可以使用旧缓存（4.2.4章）
    
    * 已经成功验证（4.3章）

注意到以上的要求可以被任意的缓存扩展重定义（5.2.3章）。

如果一个缓存的响应不用验证就能回复请求，缓存端**必须**生成一个Age头字段（5.1章），该字段值为该响应的当前年龄（4.2.3章），替换原有的Age字段（如果有的话）。
//L480
缓存端**必须**向源服务端传递请求方法是不安全的请求；例如，缓存端是不允许在没有向源服务端传递请求并收到回复之前向不安全的请求提供响应。

同样的，注意到不安全的请求可以让已经存储的响应失效，见4.4章。

当多与一个的合适的响应被缓存时，缓存端**必须**使用最新的那个响应（根据头字段中的时间字段来判断）。缓存端也可以向前传递该请求，并加上"Cache-Control: max-age=0" 或者"Cache-Control: no-cache"以消除不知道使用哪个响应的歧义。

无自带时钟的缓存端**禁止**缓存响应，除非每次回复时都重新验证。

#### 4.1. 通过Vary计算次键

当缓存端收到一个已经被缓存且带有Vary请求头（7.1.4章[RFC7231]）的的请求时,缓存端**禁止**直接使用该缓存消息，除非该请求所有跟Vary相关的字段都与缓存响应的原始请求相同。

两个请求中与Vary相关的字段定义成相同的，当且仅当第一个请求中的字段值可以通过以下任意方法转换成第二个请求中的字段值：

* 在字段值语法允许的范围内添加或删除空格

* 合并多个相同字段名的字段值（见3.2章[RFC7230]）

* 根据头字段的定义，归并两个请求中语义相同的字段（例如，在顺序不影响语义的前提下重排字段值；如果字段值时大小写敏感的话，规范大小写）

如果（经过以上的方法）一个请求的某个头字段值仍然缺失，这个请求只能去匹配其他缺失同一个头字段值的缓存响应如果有这样的缓存响应的话。

Vary头字段值为"*"的请求永远不会匹配到缓存的响应。

拥有匹配头字段值的缓存响应被称为匹配响应。
//L540
如果多个匹配响应时可用的（可能包括没有Vary头字段的响应），缓存端可能需要选择其中一个使用。当某个匹配头字段值有已知的机制来处理该问题（例如， Accept字段的qvalues和其他类似的请求头字段），这个机制**可以**优先选择哪一个响应；其他情况下，最新的响应（根据Date头字段断定）会被返回给该请求，如4章提到的。

如果没有可用的匹配响应，缓存端无法回复当前请求。一般来说，这个请求会被发送到源服务端（可能是带条件的，见4.3章）。

#### 4.2. 新鲜度

新鲜响应是指年龄未超出保质期的响应。相反的，陈旧的请求是指超出保质期的响应。

响应的保质期是指本身被源服务端创建的时间点和自身的过期时间点的时间差。过期时间更明确的定义是源服务端申明该缓存响应在该过期时间点之后不能在未验证的前提下被缓存端使用，鉴于上述情况，如果没有有效过期时间的话，缓存端会赋给该响应一个推测的过期时间。

响应的年龄是指响应被源服务端创建或被成功验证的时间点到当前点中间的时长。

如果一个响应被缓存端认为是“新鲜”的，那么该响应可以被用于回复之后的请求而不需要再向源服务端通讯，从而提升了效率。

判断是否新鲜的第一原则是要求源服务端通过Expires头字段值（5.3章）或者max-age响应指令（5.2.2.8章）提供一个明确的未来过期时间。一般来说，源服务端在确信未来过期时间之前该响应不会发生语义上重大的变化的情况下，会给该响应一个明确的未来过期时间。
//L594
如果源服务端希望缓存端验证每一个请求，那么源服务端可以给每个响应一个已经过期的过时时间来告诉缓存端该响应已经是旧的了。遵守规则的缓存端一般来说就会在复用该响应前验证这个旧的响应（见4.2.4章）。

因为源服务端经常不提供明确过期时间，缓存端在特定情境下可以自行判断当前的过期时间（见4.2.2章）。

判断响应是否为新的规则如下：

> response_is_fresh = (freshness_lifetime > current_age)

freshness_lifetime 的定义在4.2.1章; current_age 的定义在 4.2.3章。

客户端可以在请求中发送max-age或者min-fresh指令，要求限制或放松回复响应的新鲜度计算（5.2.1章）。

在计算新鲜度的时候，时间解析需要避免以下这个常见的问题：

* 尽管所有时间格式都是大小写敏感的，缓存中介**应该**忽略大小写去匹配日，星期和时区名字。

* 如果缓存中介内部的时间扩展不能很好的判断HTTP-date的话，这个中介内部**必须**将该过期时间值解析成相近的或者比该值更早的值。

* 缓存端**禁止**根据自己的时区影响年龄或者过期时间的计算和比较。

* 缓存端**应该**在计算是否过期是将一个日期当作是带有时区的而不是直接使用GMT或者UTC时区。

注意到，新鲜度只对缓存操作有关，他不能强制用户代理刷新显示或者重新加载资源。第6章有详细的关于缓存和之前机制的区别的解释。

###### 4.2.1. 计算新鲜度的生命周期

缓存端可以使用以下第一个符合的条件计算响应的新鲜度的生命周期（标记为freshness_lifetime）：

* 如果缓存端是公共的，而且下达了s-maxage响应指令（5.2.2.9章），使用该指令值。

* 如果下达了max-age响应指令（5.2.2.8章），使用该指令值。

* 如果出现Expires响应头字段(5.3章)，使用该字段值与Date响应头字段值的差值。

* 否则，如果响应中没有明确的过期时间，可以使用一个假定的值作为该响应新鲜度的生命周期；见4.2.2章。

注意到，这个计算结果不受到时钟同步的影响，因为所有信息都来自源服务端。

当有多个值可选时（例如，两个Expires头字段，多个Cache-Control字段：多个max-age指令），这些指令值时无效的。一般希望缓存端将这些带有无效新鲜度信息的响应当成是旧的。

###### 4.2.2. 计算假定的新鲜度

因为源服务端不一定会提供明确的过期时间，缓存端**可以**在没有明确过期时间的情况赋给该响应一个推测的过期时间，使用其他头字段值（例如Last-Modified）和特定的算法估计一个推测的过期时间。本规范不提供指定的算法，但是会给出最差情况下的约束。

缓存端**禁止**在已存储的响应提供明确过期时间的前提下使用推测的过期时间来判断新鲜度。因为按照第3章的规定，这意味着，实际上推测值只能用在那些没有明确新鲜度的且状态码被定义默认可缓存（见6.1章[RFC7231]）的响应上，而这些响应已经被额外标注为可缓存（例如，带有public的响应指令）。

如果响应带有Last-Modified头字段（2.2章[RFC7232]）,一般希望缓存端使用一个推测的过期时间值，这个推测值一般不大于自该字段值时间起至今的时长乘以一定比例，一般这个比例会设置为10%。

当在计算新鲜度生命周期时，缓存端使用了一个推测的过期时间且该响应的current_age不大于24小时且没有包括以下字段值，缓存端**应该**在响应中生成一个Warning头字段且warn-code值为113（见5.5.4章）。

> 注意：13.9章[RFC2616]禁止在带有参数（例如，那些包含“?”）的URI上使用推测值计算新鲜度。实际上，这个规定并没有被广泛接收。因此，一般不建议源服务端在不希望缓存的情况下发送特别明确的指令（例如，Cache-Control: no-cache）。

###### 4.2.3. 计算年龄

Age头字段是用来传输从缓存获取的响应的大概年龄的。Age字段值是缓存端关于响应被源服务端生成或者验证之后过去的以秒计的时长的估计。本质上，Age字段值是该响应在被服务端返回之后在缓存端存在的时间综合，还要加上网络传输的时长。

以下数据被用于计算年龄：

age_value

> "age_value"这个符号表示了Age头字段值（5.1章），以方便计算的形式给出，如果不存在的话就是0.

date_value
//fixme 查阅7231，最后半句啥意思啊
> "date_value"符号表示Date头字段值，以方便计算的形式给出，见7.1.1.2[RFC7231]中关于Date头字段的定义。

now

> "now"符号说明主机在计算的当下的时钟时间。主机应该使用NTP（[RFC5905]）或者某些相近的协议跟世界时间保持时钟同步。

request_time

> 指主机时钟在请求响应被缓存时的当下时间。

response_time

> 指响应被收到的时候的主机时钟的值。

响应的年龄可以用以下两种完全独立的方法来计算：

    1. "apparent_age":response_time 减去 date_value
    
    2. "corrected_age_value"




    

















































