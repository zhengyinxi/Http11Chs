   HTTP是为构建万维网(World Wide Web, WWW)架构而提出的, 经过长时间的演进, 已经能够支持全球规模的超文本系统的各类需求. 架构的很多部分都能够从HTTP的术语和语法上得到体现.

#### 2.1. C/S架构消息

   HTTP是一个无状态的请求/回复协议, 通过一个可靠的传输/会话层「连接」(第6章)交换消息(第3章). 一个HTTP「客户端」(client)是为了发送一个或多个请求, 而与服务器建立了连接(connection)的程序. 一个HTTP「服务器」(server)也是一个程序, 它接受来自客户端的连接, 服务这些客户端的HTTP请求并返回HTTP回复.

   术语「客户端」和「服务器」仅仅是为了区分一个特定连接中不同程序扮演的角色. 同一个程序可以在某些连接中扮演客户端, 而在另一些连接中扮演服务器. 术语「用户代理」(user agent)指代任何一个可以初始化请求的客户端, 包括但不限于浏览器、网络爬虫、命令行工具、定制程序、移动应用等. 对于一个给定的目标资源, 「原始服务器」(origin server)是能对该资源进行权威回复的源头. 术语「发送端」(sender)和「接收端」(recipient)则分别代表发送和接收消息的任意实现.

   HTTP依赖统一资源描述符(Uniform Resource Identifier, URI)来标识目标资源, 以及资源之间的关系. 消息在传输时使用的格式与互联网邮件(Internet mail)、多用途互联网邮件扩展(Multipurpose Internet Mail Extensions, MIME)使用的类似, 查阅附录A以了解它们之间的差异.

   多数HTTP通信中, 存在对指定资源的拉取操作(即GET操作), 这些资源就是通过URI来标识的. 最简单的情况, 这个过程仅需要用户代理(user agent, UA)和原始服务器(O)之间的一个双向连接即可完成.

   >            请求   >
   >    UA ======================================= O
   >                                <   回复

   一个客户端发送给服务器的请求消息依序包含以下内容: 
   - 一个请求行, 包含一个方法, URI, 协议版本;
   - 消息头部, 由一系列消息头部字段组成, 包含请求修饰器(request modifier), 客户端信息, 表征元数据(representation metadata), 消息头部字段以一个空行结尾;
   - 包含有效载荷的消息体(body), 消息体可能为空.

   一个发送一个或多个HTTP回复消息来应答客户端的请求. 回复消息依序包含以下内容：
   - 一个状态行, 包含一个协议版本号, 一个成功/错误码, 成功/错误码的文本解释;
   - 可选的消息头部, 由一系列消息头部字段组成, 包含服务器信息, 资源元数据, 表征元数据, 消息头部字段以一个空行结尾;
   - 包含有效载荷的消息体(body), 消息体可能为空.

   一个连接可以被多轮「请求-回复」复用.

   下面给出一个URI「http://www.example.com/hello.txt」的GET请求示例.

   客户端请求:

   >  GET /hello.txt HTTP/1.1
   >  User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
   >  Host: www.example.com
   >  Accept-Language: en, mi   
   
   服务器回复:

   >  HTTP/1.1 200 OK
   >  Date: Mon, 27 Jul 2009 12:28:53 GMT
   >  Server: Apache
   >  Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
   >  ETag: "34aa387-d-1568eb00"
   >  Accept-Ranges: bytes
   >  Content-Length: 51
   >  Vary: Accept-Encoding
   >  Content-Type: text/plain
   >
   >  Hello World! My payload includes a trailing CRLF.

####2.2. 实现差异

   当设计一个HTTP设计, 很容易陷入一个误区, 认为所有的用户代理都是全功能的浏览器, 所有的原始服务器都是大型的公共站点. 现实的情况不是这样的. 典型的用户代理包括日常使用的应用, 立体声音响(stereos?), 电子秤(scales?), 固件升级脚本, 命令行程序, 移动应用, 以及形形色色的通信设备. 类似的, 典型的原始服务器包括家庭自动化系统, 可配置网路组件, 办公机器, 自治机器人, 新闻聚合器, 电子警察, 广告选择器, 视频分发平台等. 

   术语「用户代理」并不意味着, 需要人类用户与软件代理直接交互才能发起请求. 在很多情况下, 用户代理运行在后台, 保存请求结果以供后续使用, 保存的结果可能只是原始结果中感兴趣的部分或者错误信息. 爬虫就是一种典型的用户代理, 给其一个起始URI, 配置链接跟随的行为模式, 就能在超链接形成的图中, 自动运行下去.

   HTTP实现的差异性意味着并不是所有的用户代理都能以界面交互的方式为用户提供建议, 或者在出现安全和隐私问题时给出足够的警示信息. 如果本文档规定一些错误信息必须向用户汇报时, 可以仅将错误记录在错误输出终端或日志文件中. 同样, 一些需要用户确认才能继续的操作, 可以通过高级配置选项, 运行时选项, 不安全选项的方式进行确认. 如果用户已经做过选择, 这种确认可以不必反馈在用户界面或者打断正常的处理流程. (译者注: 就是说, 用户代理可以根据配置选项, 或过去的选择结果, 代替用户进行选择.)

####2.3. 中介

   HTTP允许使用中介程序将连接组织成一条通信链. 常见的中介有代理(proxy)、网关(gateway)、隧道(tunnel)3种. 一些情况下, 一个中介可以扮演原始服务器, 代理, 网关, 或隧道等角色, 并根据每个请求的特征进行角色切换.

   >         >             >             >             >
   >    UA =========== A =========== B =========== C =========== O
   >               <             <             <             <

   上图中, 用户代理和原始服务器间有三个中介, 分别是A, B, C. 每一个请求/回复需要穿过4个独立的连接, 这4个连接形成一条通信链. 这个特征非常重要, 因为一些HTTP通信选项只能在离终端节点最近的非隧道连接上使用. 尽管图中的场景是线性的, 但实际上每一个参与方都可能同时服务于很多连接. 例如, 在处理A请求的同时, B可能接收来自A之外的其它客户端的请求, 转发给除C外的其它服务器. 后续的请求可以使用不同的连接路径进行传输, 连接路径经常因为动态配置或负载均衡的原因发生变化.

   术语「上游」(upstream)和「下游」(downstream)与信息流的传输方向有关: 所有的信息流都是从上游传输到下游. 术语「站内」(inbound)和「站外」(outbound)描述请求路由的方向: 站内和站外分别代表朝向原始路由器和朝向用户代理.

   一个「代理」是一个消息转发代理程序, 对外暴露HTTP接口, 从该接口接收来自客户端的某些类型的绝对URI请求, 并将请求翻译成合适的协议, 以便进一步处理. 有些翻译只需要最低限度的工作, 例如, 仅仅代理转发「http」URI请求; 另外一些则比较「重」, 需要将其翻译成完全不同的应用层协议. 代理的一个常见用途是将一个组织内部的HTTP请求都通过一个中介进行处理, 这个措施有安全性, 注解服务, 共享缓存等方面的考虑. 一些代理会在制定消息或消息负荷被转发时对它们进行转化, 详细细节请参加第5.7.2节.

   一个「网关」(也被称作「反向代理」)是这样一种中介, 对外, 它充当原始服务器, 对内, 它负责将收到的请求转发给内部的其它服务器或服务器集群. 网关的通常用途包括: 封装旧的或不信任的信息服务; 通过「加速器」缓存提高服务器性能; 为多台机器的HTTP服务启用分区或负载均衡.

   所有适用于原始服务器出站通信的要求同样适用于网关. 一个网关和站内服务器可以使用任何协议进行通信, 不限于HTTP及其变种. 当然, 如果需要与第三方HTTP服务交互, 且这些第三方服务器对网关接入的连接有user agent要求, 就需要HTTP-to-HTTP的网关.

   一个「隧道」是两个连接的「盲」中介, 转发而不更改消息内容. 尽管一条隧道可能被HTTP请求初始化, 但一旦启用, 就被当做HTTP通信的一部分. 当两端的连接同时被关闭, 隧道也会随之终止. 隧道被用于通过中介来扩展虚拟连接, 例如, 通过TLS建立能够穿越防火墙的机密连接.

   上述中介的分类是从它们在HTTP通信中扮演的角色划分的. 实际上, 在网络协议栈的底层可能存在其它中介, 这些底层的中介无需知悉HTTP发送者的任何信息, 也无需顾忌发送者是否允许, 就可以对HTTP流量进行过滤和转发. 在「中间人攻击」(man-in-the-middle attack)中, 仅从协议层是无法判断是否存在网络中介的, 这导致误解了HTTP语义, 从而引发安全和互操作问题. 

   HTTP是一个无状态的协议, 每一个请求消息可被独立解释. 许多实现利用HTTP无状态这一点, 重复利用代理连接, 或者在多台服务器间进行请求负载均衡. 因此, 除非连接已经安全绑定到特定的用户代理, 一个服务器**禁止**假设同一连接的两个请求一定来自同一用户代理. 一些非标准的HTTP扩展(RFC4559)必须理解这个要求, 以避免安全和互操作问题.

####2.4. 缓存

   一个「缓存」是对先前已回复消息的本地存储, 由缓存系统控制消息的存储, 获取, 删除. 缓存存储可缓存回复的目的是为了降低未来相同请求的响应时间和网络带宽消耗量. 任何客户端或服务器都**可以**实现一个缓存, 当一个服务器以隧道方式运行时缓存不可使用.

   只要请求/回复链的任何参与方有缓存的回复, 缓存能使请求/回复链的长度缩短. 下图给出了一个示例, 其中, B缓存了来自O(通过C)的旧回复, 这个回复尚未被UA或A缓存.

   >
   >            >             >
   >       UA =========== A =========== B - - - - - - C - - - - - - O
   >                  <             <

   一个回复是「可缓存」的, 如果回复消息的副本允许被存储以应答后续的请求. 当然, 即使一个回复是可缓存的, 客户端或原始服务器仍然可能存在其它限制, 限制缓存的回复被应用于特定的请求. HTTP对缓存行为和可缓存回复的要求在RFC7234第二章定义.

   在万维网和大组织内部, 存在各种缓存架构和配置的变体, 包括:

   - 全国性的分层代理缓存, 能够节省跨洋带宽;
   - 协作系统, 广播/多播缓存记录, 预取后用于改善离线, 高延时等环境下的性能.

####2.5. 一致性和错误处理

   本文档根据HTTP通信中参与方角色来确定一致性标准. 不同的角色, 如发送者, 接收者, 客户端, 服务器, 用户代理, 中介, 原始服务器, 代理, 网关, 缓存, 其行为受到不同要求的约束. 具体的实现, 资源拥有者, 协议元素注册应用在单连接通信外时, 可能会有附加的要求.

   动词「生成」(generate)取代「发送」(send) 用于区分生成协议要素还是仅仅向下游转发接收的内容。
   
   一个扩展需要在HTTP中有关联的部分与http协议保持一致性。
  
   一致性包括在协议元素上的语法和语义的一致性，发送端「sender」**禁止** 生成说明自身并非发送端「sender」的协议要素。发送端「sender」**禁止**生成不符合响应「ABNF」规则定义的语法的协议要素。对于某个特定的消息，发送端「sender」**禁止**生成需要其他角色（例如，修改该信息需要而发送端没有的角色）参与生成的协议要素和替代语法。
   
   当解析完一个接收到的协议要素，接收端「recipient」**必须**解析本角色应该解析的长度合适的且符合响应「ABNF」规则定义的语法的内容。例如，中介在向前传输消息时可能会将请求头中的字段解析成更一般的字段名和字段值，但是发送时不会进一步解析该字段值。
   
   HTTP对于大部分的协议要素没有指定的长度限制，这是因为每个协议要素的合适的长度各异，而且依赖于部署的环境和这个扩展的适用场景。因此，发送端「sender」和接收端「recipients」之间的相互操作是基于对合适的各个协议要素的长度所达成的共识。此外，对于各个协议要素的长度所达成的共识随着二十年来不断使用HTTP不断变化，而且在可以预见的未来还会继续变化。
   
   最低程度上，接收端「recipient」**必须**可以解析和处理长度不大于本身生成「generate」的其他基于该协议的消息中的要素长度的协议要素。例如，一个原始的服务端必须能解析这样一个请求，这个请求是自身发布的一个引用自身资源但是非常长的URI

   接收端「recipient」**必须**根据本协议实现接收的协议要素，包括本协议的扩展，除非接收端「recipient」能确定（根据经验或者配置）发送端「sender」错误实现语义的定义。例如，一个原始的服务端在检查到User-Agent的值表明该请求实现了某个特定的协议扩展而该扩展已知无法接收特定的内容编码格式「content codings」，可能会忽略接收到的Accept-Encoding 请求头内容。
   
   除非有其他说明，接收端「recipient」可以尝试从一个无效的结构中恢复一个有用的协议要素。除非直接影响安全，HTTP没有定义特定的错误处理机制，既然不同的协议应用需要不同的错误处理策略。例如，网页浏览器可能期望重新获得一个Location请求头根据ABNF规则无法解析的请求，然而一个系统控制的客户端却认为这种行为是危险的。

####2.6. 协议的版本

   HTTP使用 「<主版本号>.<次版本号>」的规则表明协议的版本。 本协议定义了版本「1.1」.作为一个整体的协议版本，指示设置了该版本的 HTTP 相应规范中规定要求发送方的一致性。
   
   HTTP消息的版本号由消息第一行中的HTTP-version字段表明，该字段是大小写敏感的。
   
   > HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
   > HTTP-name     = %x48.54.54.50 ; "HTTP", case-sensitive
   
   HTTP版本号由两个用「.」（小数点）分隔的十进制的数字组成。第一个数字（「主版本」）表明该HTTP消息的语法，第二个数字（「次版本」）表明该主版本号下发送方能接收并能理解的最高次版本号。次版本号说明了发送端的通讯能力，即使该发送端使用了向后兼容的协议子集，因此接收端了解到这样一个事实，一些更先进的特性可以在与该发送端通讯中使用，包括回复（服务端生成）和以后的请求（客户端生成）。
   
   当一个HTTP/1.1 的消息被发送到一个HTTP/1.0或者未知版本号的接收端时，这个消息会被构造成一个有效的HTTP1.0的消息，这样的话一些较新的特性会被服务端忽略。这个说明将接收端对于这些新特性的要求告知发送端，这样一来发送端也只会使用兼容的特性，除非某些特性在发送和接收的过程中能同时被发送端和接收端确认可以使用或者接收的信息是支持HTTP/1.1的。
   
   对于同一个协议头字段值来说，它的解释不会因为次版本号的变化而变化，前提是主版本号是相同的，然而缺省行为可以是不同的。除非额外说明，HTTP/1.1中定义的头字段在所有的HTTP/1.x中均可以使用。尤其是Host和Connection头字段必须在所有HTTP/1.x扩展中使用，不管这个HTTP/1.x扩展是否声称自己支持HTTP/1.1。
   
   不更改协议版本号也能加入新的头字段,只要自定义的头字段可以被其他不支持该字段的接收端忽略。头字段的扩展性会在3.2.1章节中讨论。
   
   所有处理HTTP消息的中介（例如，除了当作通道使用的所有中介）在向前传送消息是**必须**发送自己的HTTP-version头字段。换一句话说，在不确定协议版本号是否匹配自身发送接收消息的版本号的前提下，中介不能盲目的向前传送HTTP消息的第一行。向前传送HTTP消息却不重写HTTP-version头字段值会导致通讯错误，当下游的接收端使用消息发送端的版本号来确定随后通讯中能安全使用特性，这种错误就会发生。
   
   客户端**应该**发送一个发送自身能支持的且主版本号不超过服务端能支持的最高主版本号的最高版本号。客户端**禁止**发送违背上述描述的版本号。
   
   客户端**可以**发送一个较低的版本号，如果客户端知道服务端错误的实现了HTTP规范，当且仅当客户端尝试过一次正常的请求之后发现响应状态码或回复头字段（例如：Server）错误的处理了高版本号。
   
   服务端**应该**发送一个主版本号小于等于请求中的版本号的且服务端能支持的最大响应版本号。服务端**禁止**发送与上述描述不一致的版本号。如果愿意的话，服务端可以以任何理由发送505（HTTP版本不支持）的响应，并拒绝以客户端的协议主版本号提供服务。
   
   在知道客户端错误的实现协议规范且无法正确处理随后响应的前提下，服务端**可以**发送一个HTTP/1.0的响应，比如当客户端无法这却解析版本号或者中介在无法确定给定的协议次版本号的前提下盲目的向前传送HTTP-version。除非一些特殊的客户端属性的触发，例如某些请求头字段（例如，User-Agent）中出现特定能到处故障的值，这样的版本号降级**不应该**发生。
   
   HTTP的版本号控制的设计意图是希望在某些不见如的消息语法下，主版本号只会递增，并且当修改协议的同时增加了消息的语法或者增加了发送端的额外功能时，次版本号也是递增的。然而，在 [RFC2068] 和 [RFC2616]次版本号不会变化 ，这次修订特意避开了协议的此类更改。
   
   当一个带着服务端支持的主版本号和比服务端支持的此版本号更高的版本号的HTTP消息被服务端收到时，接收端**应该**将该消息的版本号当作本身能支持的最高次版本号来处理。接收端可以假设带有更高次版本号的消息是充分向后兼容同一主版本号下的任意版本的。
      
                                                                                      
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   